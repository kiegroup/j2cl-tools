// Generated from "nativekttypes/Main.java"
@file:OptIn(ExperimentalObjCName::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "REPEATED_BOUND",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER")

package nativekttypes

import javaemul.lang.*
import java.lang.Class
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmField
import kotlin.jvm.javaObjectType
import kotlin.native.ObjCName
import nativekttypes.Fn
import nativekttypes.nativekt.KBridge
import nativekttypes.nativekt.KCompanionObject
import nativekttypes.nativekt.KFunctionalInterfaceBridge
import nativekttypes.nativekt.KFunctionalInterfaceRequiringBridge
import nativekttypes.nativekt.KInterface
import nativekttypes.nativekt.KRequiringBridge
import nativekttypes.nativekt.KTopLevel
import nativekttypes.nativekt.KWithCompanionObject

@ObjCName("J2ktNativekttypesMain", exact = true)
open class Main {
 @JvmField
 @ObjCName("topLevelField_")
 var topLevelField: KTopLevel<String?>? = null

 @JvmField
 @ObjCName("nestedField_")
 var nestedField: KTopLevel.KNested<String?>? = null

 @JvmField
 @ObjCName("innerField_")
 var innerField: KTopLevel<String?>.KInner<String?>? = null

 @ObjCName("methodArguments")
 open fun methodArguments(
  @ObjCName("withNativekttypesNativeTopLevel") foo: KTopLevel<String?>?,
  @ObjCName("withNativekttypesNativeTopLevel_Nested") nested: KTopLevel.KNested<String?>?,
  @ObjCName("withNativekttypesNativeTopLevel_Inner") inner: KTopLevel<String?>.KInner<String?>?
 ) {}

 @ObjCName("memberAccess")
 open fun memberAccess() {
  val topLevel: KTopLevel<String?>? = KTopLevel<String?>("foo")
  val fooInstanceMethod: String? = topLevel!!.instanceMethod("foo")
  val fooStaticMethod: String? = KTopLevel.staticMethod<String?>("foo")
  val fooInstanceField: String? = topLevel!!.instanceField
  topLevel!!.instanceField = "foo"
  val fooStaticField: Any? = KTopLevel.staticField
  KTopLevel.staticField = "foo"
  val i1: Int = topLevel!!.renamedField
  val i2: Int = topLevel!!.renamedMethod()
  val i3: Int = topLevel!!.methodAsProperty
  val i4: Int = topLevel!!.nonGetMethodAsProperty
  val i5: Int = topLevel!!.renamedMethodAsProperty
  val i6: Boolean = topLevel!!.isRenamedField
  val i7: Boolean = topLevel!!.isMethodAsProperty
  val i8: Int = topLevel!!.getstartingmethodAsProperty
  val nested: KTopLevel.KNested<String?>? = KTopLevel.KNested<String?>("foo")
  val nestedInstanceMethod: String? = nested!!.instanceMethod("foo")
  val nestedStaticMethod: String? = KTopLevel.KNested.staticMethod<String?>("foo")
  val nestedInstanceField: String? = nested!!.instanceField
  nested!!.instanceField = "foo"
  val nestedStaticField: Any? = KTopLevel.KNested.staticField
  KTopLevel.KNested.staticField = "foo"
  val nestedAnonynous: KTopLevel.KNested<String?>? = object : KTopLevel.KNested<String?>("foo") {}
  val inner: KTopLevel<String?>.KInner<String?>? = topLevel!!.KInner<String?>("foo")
  val subclass: Subclass<String?>? = Subclass<String?>("foo")
  val i9: Int = subclass!!.renamedMethod()
  val i10: Int = subclass!!.interfaceMethod("foo")
  val i11: Int = subclass!!.renamedInterfaceMethod("foo")
  val interfaceAnonymousSubclass: KInterface.KFunctionalInterface? = object : KInterface.KFunctionalInterface {
   override fun run() {}
  }
  val interfaceExpression: KInterface.KFunctionalInterface? = KInterface.KFunctionalInterface {
   return@KFunctionalInterface
  }
 }

 @ObjCName("bridges")
 open fun bridges() {
  var o: KRequiringBridge? = KBridge()
  o = object : KBridge() {}
  o = BridgeSubclass()
  var fi: KFunctionalInterfaceRequiringBridge<String?>? = null
  fi = KFunctionalInterfaceBridge<String?> { s: String? ->
   return@KFunctionalInterfaceBridge s
  }
  fi = object : KFunctionalInterfaceBridge<String?> {
   override fun foo(s: String?): String? {
    return s
   }
  }
  val cast: KRequiringBridge? = o as KRequiringBridge?
  val instanceofCheck: Boolean = o is KRequiringBridge
 }

 @ObjCName("casts")
 open fun casts() {
  val o1: KTopLevel<String?>? = null as KTopLevel<String?>?
  val o2: KTopLevel.KNested<String?>? = null as KTopLevel.KNested<String?>?
  val o3: KTopLevel<String?>.KInner<String?>? = null as KTopLevel<String?>.KInner<String?>?
 }

 @ObjCName("companionObject")
 open fun companionObject() {
  val o: KWithCompanionObject? = KWithCompanionObject()
  val i1: Int = o!!.instanceField
  o!!.instanceMethod()
  KCompanionObject.staticMethod()
  val i2: Int = KCompanionObject.staticField
  KCompanionObject.staticField = i2
 }

 @ObjCName("typeLiterals")
 open fun typeLiterals() {
  val c1: Class<*>? = KTopLevel::class.javaObjectType
  val c2: Class<*>? = KTopLevel.KNested::class.javaObjectType
  val c3: Class<*>? = KTopLevel.KInner::class.javaObjectType
 }

 @ObjCName("disabledVoidMethod")
 open fun disabledVoidMethod() {}

 @ObjCName("disabledNonVoidMethod")
 open fun disabledNonVoidMethod(): Boolean {
  return false
 }

 @ObjCName("acceptFn_generic")
 open fun <I, O> acceptFn_generic(
  @ObjCName("withNativekttypesFn") f: Fn<I, O>?,
  @ObjCName("withId") i: I
 ): O {
  return f!!.apply(i)
 }

 @ObjCName("acceptFn_parametrized")
 open fun acceptFn_parametrized(
  @ObjCName("withNativekttypesFn") f: Fn<String?, String?>?,
  @ObjCName("withNSString") i: String?
 ): String? {
  return f!!.apply(i)
 }

 @ObjCName("acceptFn_genericWildcard")
 open fun <I, O> acceptFn_genericWildcard(
  @ObjCName("withNativekttypesFn") f: Fn<I, O>?,
  @ObjCName("withId") i: I
 ): O {
  return (f as Fn<I, O>?)!!.apply(i)
 }

 @ObjCName("acceptFn_parametrizedWildcard")
 open fun acceptFn_parametrizedWildcard(
  @ObjCName("withNativekttypesFn") f: Fn<String?, String?>?,
  @ObjCName("withNSString") i: String?
 ): String? {
  return (f as Fn<String?, String?>?)!!.apply(i)
 }

 @ObjCName("acceptFn_unboundWildcard")
 open fun acceptFn_unboundWildcard(
  @ObjCName("withNativekttypesFn") f: Fn<*, *>?,
  @ObjCName("withId") i: Any?
 ): Any? {
  return (f as Fn<Any?, Any?>?)!!.apply(i)
 }

 @ObjCName("acceptFn_raw")
 open fun acceptFn_raw(
  @ObjCName("withNativekttypesFn") f: Fn<Any?, Any?>?,
  @ObjCName("withId") i: Any?
 ): Any? {
  return f!!.apply(i)
 }
}

open class Subclass<V>: KTopLevel<V>, KInterface<V> {
 constructor(v: V): super(v)

 open override fun renamedMethod(): Int {
  return super<KTopLevel>.renamedMethod()
 }

 open override val methodAsProperty: Int get() {
  return super<KTopLevel>.methodAsProperty
 }

 open override val nonGetMethodAsProperty: Int get() {
  return super<KTopLevel>.nonGetMethodAsProperty
 }

 open override val renamedMethodAsProperty: Int get() {
  return super<KTopLevel>.renamedMethodAsProperty
 }

 open override val getRenamedMethodAsProperty: Int get() {
  return super<KTopLevel>.getRenamedMethodAsProperty
 }

 open override val isMethodAsProperty: Boolean get() {
  return super<KTopLevel>.isMethodAsProperty
 }

 open override val getstartingmethodAsProperty: Int get() {
  return super<KTopLevel>.getstartingmethodAsProperty
 }

 open override fun interfaceMethod(v: V): Int {
  return 0
 }

 open override fun renamedInterfaceMethod(v: V): Int {
  return 0
 }

 open override val interfaceMethodAsProperty: Int get() {
  return 0
 }

 open override val renamedInterfaceMethodAsProperty: Int get() {
  return 0
 }
}

open class Subsubclass<V>: Subclass<V> {
 constructor(v: V): super(v)

 open override fun renamedMethod(): Int {
  return super<Subclass>.renamedMethod()
 }

 open override val methodAsProperty: Int get() {
  return super<Subclass>.methodAsProperty
 }

 open override val nonGetMethodAsProperty: Int get() {
  return super<Subclass>.nonGetMethodAsProperty
 }

 open override val renamedMethodAsProperty: Int get() {
  return super<Subclass>.renamedMethodAsProperty
 }

 open override val getRenamedMethodAsProperty: Int get() {
  return super<Subclass>.getRenamedMethodAsProperty
 }

 open override val isMethodAsProperty: Boolean get() {
  return super<Subclass>.isMethodAsProperty
 }

 open override val getstartingmethodAsProperty: Int get() {
  return super<Subclass>.getstartingmethodAsProperty
 }

 open override fun interfaceMethod(v: V): Int {
  return 0
 }

 open override fun renamedInterfaceMethod(v: V): Int {
  return 0
 }

 open override val interfaceMethodAsProperty: Int get() {
  return 0
 }

 open override val renamedInterfaceMethodAsProperty: Int get() {
  return 0
 }
}

open class BridgeSubclass: KBridge() {
 open override fun method() {
  super<KBridge>.method()
 }
}
