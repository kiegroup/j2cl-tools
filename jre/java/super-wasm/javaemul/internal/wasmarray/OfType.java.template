  static class %ARRAY_TYPE_NAME% extends WasmArray {

    %TYPE_NAME%[] elements;

    %ARRAY_TYPE_NAME%(int length) {
      super(length);
      // Do explicit construction of 0 length arrays because those are optimized to preallocated
      // singletons.
      this.elements = (length == 0) ? new %TYPE_NAME%[0] : new %TYPE_NAME%[length];
    }

    %ARRAY_TYPE_NAME%(%TYPE_NAME%[] initialValues) {
      super(initialValues.length);
      this.elements = initialValues;
    }

    @Override
    Object newArray(int length) {
      return new WasmArray.%ARRAY_TYPE_NAME%(length);
    }

    @Override
    void setLength(int newLength) {
      ensureCapacity(newLength);
      if (newLength < length) {
        // Clear to outside contents
        for (int i = newLength; i < length; i++) {
          elements[i] = %DEFAULT_VALUE%;
        }
      }
      length = newLength;
    }

    public void push(%TYPE_NAME% o) {
      int newLength = length + 1;
      ensureCapacity(newLength);
      elements[length] = o;
      length = newLength;
    }

    private void ensureCapacity(int newLength) {
      if (newLength > elements.length) {
        // Not enough capacity, increase it.
        %TYPE_NAME%[] original = elements;
        elements = new %TYPE_NAME%[getNewCapacity(length, newLength)];
        copy(elements, 0, original, 0, original.length);
      }
    }

#IF OfByte OfShort OfInt OfLong OfChar OfFloat OfDouble
    /**
     * Performs a merge sort on the specified portion of an object array.
     *
     * <p>Uses O(n) temporary space to perform the merge, but is stable.
     */
    @Override
    void sort(int fromIndex, int toIndex) {
      %TYPE_NAME%[] temp = new %TYPE_NAME%[toIndex - fromIndex];
      copy(temp, 0, elements, fromIndex, temp.length);
      mergeSort(temp, elements, fromIndex, toIndex, -fromIndex);
    }

    /**
    * Recursive helper function for {@link #sort(T[], int, int)}.
    *
    * @param temp temporary space, as large as the range of elements being sorted. On entry, temp
    *     should contain a copy of the sort range from array.
    * @param array array to sort
    * @param low lower bound of range to sort
    * @param high upper bound of range to sort
    * @param ofs offset to convert an array index into a temp index
    */
    private static void mergeSort(
        %TYPE_NAME%[] temp, %TYPE_NAME%[] array, int low, int high, int ofs) {
      int length = high - low;

      // insertion sort for small arrays
      if (length < 7) {
        insertionSort(array, low, high);
        return;
      }

      // recursively sort both halves, using the array as temp space
      int tempLow = low + ofs;
      int tempHigh = high + ofs;
      int tempMid = tempLow + ((tempHigh - tempLow) >> 1);
      mergeSort(array, temp, tempLow, tempMid, -ofs);
      mergeSort(array, temp, tempMid, tempHigh, -ofs);

      // Skip merge if already in order - just copy from temp
      if (!isGreaterThan(temp[tempMid - 1], temp[tempMid])) {
        while (low < high) {
          array[low++] = temp[tempLow++];
        }
        return;
      }

      // merge sorted halves
      merge(temp, tempLow, tempMid, tempHigh, array, low, high);
    }

    /**
     * Sort a small subsection of an array by insertion sort.
     *
     * @param array array to sort
     * @param low lower bound of range to sort
     * @param high upper bound of range to sort
     */
    private static void insertionSort(%TYPE_NAME%[] array, int low, int high) {
      for (int i = low + 1; i < high; ++i) {
        for (int j = i; j > low && isGreaterThan(array[j - 1], array[j]); --j) {
          %TYPE_NAME% t = array[j];
          array[j] = array[j - 1];
          array[j - 1] = t;
        }
      }
    }

    /**
     * Merge the two sorted subarrays (srcLow,srcMid] and (srcMid,srcHigh] into dest.
     *
     * @param src source array for merge
     * @param srcLow lower bound of bottom sorted half
     * @param srcMid upper bound of bottom sorted half & lower bound of top sorted half
     * @param srcHigh upper bound of top sorted half
     * @param dest destination array for merge
     * @param destLow lower bound of destination
     * @param destHigh upper bound of destination
     */
    private static void merge(
        %TYPE_NAME%[] src,
        int srcLow,
        int srcMid,
        int srcHigh,
        %TYPE_NAME%[] dest,
        int destLow,
        int destHigh) {
      // can't destroy srcMid because we need it as a bound on the lower half
      int topIdx = srcMid;
      while (destLow < destHigh) {
        if (topIdx >= srcHigh || (srcLow < srcMid && !isGreaterThan(src[srcLow], src[topIdx]))) {
          dest[destLow++] = src[srcLow++];
        } else {
          dest[destLow++] = src[topIdx++];
        }
      }
    }
#ENDIF
#IF OfByte OfShort OfInt OfLong OfChar

    private static boolean isGreaterThan(%TYPE_NAME% x, %TYPE_NAME% y) {
      return x > y;
    }
#ENDIF
#IF OfFloat

    private static boolean isGreaterThan(%TYPE_NAME% x, %TYPE_NAME% y) {
      return Float.compare(x, y) > 0;
    }
#ENDIF
#IF OfDouble

    private static boolean isGreaterThan(%TYPE_NAME% x, %TYPE_NAME% y) {
      return Double.compare(x, y) > 0;
    }
#ENDIF

#IF OfObject OfBoolean
    @Override
    void sort(int fromIndex, int toIndex) {
      throw new UnsupportedOperationException();
    }
#ENDIF

    @Override
    void copyFrom(int offset, WasmArray values, int valueOffset, int len) {
      copy(elements, offset, ((WasmArray.%ARRAY_TYPE_NAME%) values).elements, valueOffset, len);
    }

    @JsMethod // Keep JsInteropRestrictionsChecker happy.
    @Wasm("array.copy $%TYPE_NAME%.array $%TYPE_NAME%.array ")
    private static native void copy(Object dest, int destOfs, Object src, int srcOfs, int len);

#IF OfObject
    public void insertFrom(int insertIndex, WasmArray.%ARRAY_TYPE_NAME% values) {
      %TYPE_NAME%[] original = elements;
      int newLength = length + values.length;

      // Ensure enough capacity.
      if (newLength > elements.length) {
        elements = new %TYPE_NAME%[getNewCapacity(elements.length, newLength)];
        // Copy only up to index since the other will be moved anyway.
        copy(this.elements, 0, original, 0, insertIndex);
      }

      // Make room for the values that will be inserted by moving the existing elements to the
      // end so that they are not overwritten.
      int insertEndIndex = insertIndex + values.length;
      copy(this.elements, insertEndIndex, original, insertIndex, newLength - insertEndIndex);

      // Copy new values into the insert location.
      copy(this.elements, insertIndex, values.elements, 0, values.length);

      // Adjust the final size to cover all copied items
      length = newLength;
    }
#ENDIF
  }
