// Generated from "jsvarargs/Main.java"
@file:OptIn(ExperimentalObjCName::class, ExperimentalObjCRefinement::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "REPEATED_BOUND",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER")

package jsvarargs

import javaemul.lang.*
import kotlin.Any
import kotlin.Array
import kotlin.Int
import kotlin.IntArray
import kotlin.OptIn
import kotlin.Suppress
import kotlin.arrayOf
import kotlin.collections.MutableList
import kotlin.experimental.ExperimentalObjCName
import kotlin.experimental.ExperimentalObjCRefinement
import kotlin.intArrayOf
import kotlin.jvm.JvmField
import kotlin.jvm.JvmStatic
import kotlin.native.HiddenFromObjC
import kotlin.native.ObjCName

@ObjCName("J2ktJsvarargsMain", exact = true)
open class Main {
 @JvmField
 @HiddenFromObjC
 var field_pp_jsvarargs: Int = 0

 constructor(
  @ObjCName("Int") f: Int
 ) {
  this.field_pp_jsvarargs = f
 }

 @ObjCName("f3")
 open fun f3(
  @ObjCName("withInt") m: Int,
  vararg @ObjCName("withIntArray") numbers: Int
 ): Int {
  return this.field_pp_jsvarargs + m + numbers!![1]
 }

 @ObjCName("f4")
 open fun f4(
  vararg @ObjCName("withIntArray") numbers: Int
 ): Int {
  return this.field_pp_jsvarargs + numbers!![1]
 }

 @ObjCName("testStaticMethodNotFirst")
 open fun testStaticMethodNotFirst() {
  Main.f1(1, 1, 2)
  Main.f1(1, 1, 2)
  Main.f1(1)
  Main.f1(1)
  Main.f1(1, 1, 2)
  Main.f1(1, 1, 2)
  Main.f1(1)
  Main.f1(1)
  val ints: IntArray? = intArrayOf(1, 2)
  Main.f1(1, *ints!!)
  Main.f1(1, *ints!!)
  Main.f1(1, *null!!)
 }

 @ObjCName("testStaticMethodFirst")
 open fun testStaticMethodFirst() {
  Main.f2(1, 2)
  Main.generics<Int?>(Int.valueOf(1), Int.valueOf(2))
  Main.f2(1, 2)
  Main.generics<Int?>(Int.valueOf(1), Int.valueOf(2))
  Main.f2()
  Main.generics<Any?>()
  Main.f2()
  Main.generics<Any?>()
  Main.generics<Int?>()
  Main.f2(1, 2)
  Main.f2(1, 2)
  Main.generics<IntArray?>(intArrayOf(1, 2))
  Main.generics<Int?>(Int.valueOf(1), Int.valueOf(2))
  Main.f2()
  Main.f2()
  Main.generics<IntArray?>(intArrayOf())
  val ints: IntArray? = intArrayOf(1, 2)
  val integers: Array<Int?>? = arrayOf<Int?>(Int.valueOf(1), Int.valueOf(2))
  Main.f2(*ints!!)
  Main.f2(*ints!!)
  Main.generics<Int?>(*integers!!)
 }

 @ObjCName("testInstanceMethodNotFirst")
 open fun testInstanceMethodNotFirst() {
  val m: Main? = Main(1)
  m!!.f3(1, 1, 2)
  m!!.f3(1)
  m!!.f3(1, 1, 2)
  m!!.f3(1)
  val ints: IntArray? = intArrayOf(1, 2)
  m!!.f3(1, *ints!!)
 }

 @ObjCName("testInstanceMethodFirst")
 open fun testInstanceMethodFirst() {
  val m: Main? = Main(1)
  m!!.f4(1, 2)
  m!!.f4()
  m!!.f4(1, 2)
  m!!.f4()
  val ints: IntArray? = intArrayOf(1, 2)
  m!!.f4(*ints!!)
 }

 @ObjCName("testJsFunction")
 open fun testJsFunction() {
  val a: Main.AFunction? = Main.AFunction()
  val o1: Any? = Any()
  val o2: Any? = Any()
  a!!.f1(0, o1, o2)
  a!!.f1(0)
  a!!.f1(0, o1, o2)
  a!!.f1(0)
  val os: Array<Any?>? = arrayOf<Any?>(o1, o2)
  a!!.f1(0, *os!!)
 }

 @ObjCName("testSideEffect")
 open fun testSideEffect() {
  val ints: IntArray? = intArrayOf(1, 2)
  Main(1).f3(1, *ints!!)
 }

 @ObjCName("testNullJsVarargs")
 open fun testNullJsVarargs() {
  val ints: IntArray? = null
  Main.f2(*ints!!)
 }

 @ObjCName("testGenericJsFunctionWithVarags")
 open fun <U> testGenericJsFunctionWithVarags() {
  val function: Main.GenericFunction<U>? = Main.GenericFunction<U> { n: U, param: Array<out U>? ->
   val param_1: Array<U>? = param as Array<U>?
   return@GenericFunction param_1
  }
 }

 @ObjCName("J2ktJsvarargsMainCompanion", exact = true)
 companion object {
  @JvmStatic
  @ObjCName("f1")
  fun f1(
   @ObjCName("withInt") multiplier: Int,
   vararg @ObjCName("withIntArray") numbers: Int
  ): Int {
   return numbers!!.size + numbers!![0] + multiplier
  }

  @JvmStatic
  @ObjCName("f2")
  fun f2(
   vararg @ObjCName("withIntArray") numbers: Int
  ): Int {
   return numbers!!.size + numbers!![0]
  }

  @JvmStatic
  @ObjCName("generics")
  fun <T> generics(
   vararg @ObjCName("withNSObjectArray") elements: T
  ): T {
   val elements_1: Array<T>? = elements as Array<T>?
   return elements_1!![0]
  }

  @JvmStatic
  @ObjCName("parameterizedType")
  fun parameterizedType(
   vararg @ObjCName("withJavaUtilListArray") elements: MutableList<Main?>?
  ): Main? {
   val elements_1: Array<MutableList<Main?>?>? = elements as Array<MutableList<Main?>?>?
   return elements_1!![0]!!.get(0)
  }

  @JvmStatic
  @ObjCName("parameterizedByT")
  fun <T> parameterizedByT(
   vararg @ObjCName("withJavaUtilListArray") elements: MutableList<T>?
  ): T {
   val elements_1: Array<MutableList<T>?>? = elements as Array<MutableList<T>?>?
   return elements_1!![0]!!.get(0)
  }
 }

 open class NativeObject {
  constructor(
   vararg @ObjCName("NSObjectArray") pars: Any?
  ) {
   val pars_1: Array<Any?>? = pars as Array<Any?>?
  }
 }

 open class SubVarargsConstructorClass: Main.NativeObject {
  constructor(
   @ObjCName("Int") i: Int,
   vararg @ObjCName("withNSObjectArray") args: Any?
  ): super(*(args as Array<Any?>?)!!) {
   val args_1: Array<Any?>? = args as Array<Any?>?
  }
 }

 fun interface Function {
  @ObjCName("f1")
  fun f1(
   @ObjCName("withInt") i: Int,
   vararg @ObjCName("withNSObjectArray") args: Any?
  ): Any?
 }

 @ObjCName("J2ktJsvarargsMain_AbstractMethodWithVarargs", exact = true)
 abstract class AbstractMethodWithVarargs {
  @ObjCName("abstractMethod")
  abstract fun abstractMethod(
   vararg @ObjCName("withIntArray") args: Int
  )
 }

 @ObjCName("J2ktJsvarargsMain_StaticInterfaceMethodWithVarargs", exact = true)
 interface StaticInterfaceMethodWithVarargs {
  @ObjCName("J2ktJsvarargsMain_StaticInterfaceMethodWithVarargsCompanion", exact = true)
  companion object {
   @JvmStatic
   @ObjCName("staticMethod")
   fun staticMethod(
    vararg @ObjCName("withIntArray") args: Int
   ) {}
  }
 }

 class AFunction: Main.Function {
  override fun f1(i: Int, vararg args: Any?): Any? {
   val args_1: Array<Any?>? = args as Array<Any?>?
   return args_1!![i]
  }
 }

 open class SubMain: Main {
  constructor(): super(10)

  open override fun f3(m: Int, vararg numbers: Int): Int {
   var a: Int = super<Main>.f3(1, 1, 2)
   a = a + super<Main>.f3(1)
   a = a + super<Main>.f3(1, 1, 2)
   a = a + super<Main>.f3(1)
   val ints: IntArray? = intArrayOf(1, 2)
   a = a + super<Main>.f3(1, *ints!!)
   return a
  }
 }

 fun interface GenericFunction<T> {
  @ObjCName("m")
  fun m(
   @ObjCName("withId") i: T,
   vararg @ObjCName("withNSObjectArray") args: T
  ): Any?
 }
}
